#!/usr/bin/perl
##############################################################################
#
# Script:   bcvi
#
# The 'Back-Channel vim' tool works with SSH to allow commands which are run
# on an SSH server to invoke processes back on the originating SSH client
# machine.
#
# Use 'bcvi --help' for the documentation
#
# Copyright (c) 2007-2010 Grant McLean <grantm@cpan.org.nz>
#

use strict;
use warnings;

$BCVI::VERSION   = '3.00';

BCVI->base_init();

BCVI->load_plugins();

BCVI->base_class()->process_command_line();

exit;

##############################################################################
# This package implements some common functionality required by both the
# client and the server.
##############################################################################

package BCVI;

use Getopt::Long qw(GetOptions);

our(%class_map, %options, @aliases);
BEGIN {
    %class_map = (
        base   => 'BCVI',
        client => 'BCVI::Client',
        server => 'BCVI::Server',
        pod    => 'BCVI::POD',
    );
}

sub version      { return $BCVI::VERSION;     }
sub base_class   { return $class_map{base};   }
sub client_class { return $class_map{client}; }
sub server_class { return $class_map{server}; }
sub pod_class    { return $class_map{pod};    }


sub base_init {
    my($class) = @_;

    $class->register_option(
        name        => 'help',
        alias       => '?',
        dispatch_to => 'show_help',
        summary     => 'detailed help message',
        description => <<'END_POD'
Display this documentation.
END_POD
    );

    $class->register_option(
        name        => 'add-aliases',
        dispatch_to => 'add_aliases',
        summary     => 'install bcvi into shell startup files',
        description => <<'END_POD'
Edit the bash startup script to add (or update) the required command aliases
for bcvi
END_POD
    );

    $class->register_option(
        name        => 'listener',
        alias       => 'l',
        dispatch_to => 'start_listener',
        summary     => 'start in listener mode',
        description => <<'END_POD'
Start a background listener process.  Also generates a new authentication key.
END_POD
    );

    $class->register_option(
        name        => 'install',
        arg_name    => '<hosts>',
        dispatch_to => 'install_to_hosts',
        summary     => 'copy bcvi to named hosts and install aliases',
        description => <<'END_POD'
Copy the C<bcvi> script to the C<$HOME/bin> directory on the specified host
and then remotely invoke it with the C<--add-aliases> option.
END_POD
    );

    $class->register_option(
        name        => 'unpack-term',
        dispatch_to => 'unpack_term',
        summary     => 'unpack the overloaded TERM variable',
        description => <<'END_POD'
This option is intended for use from a F<.profile> script.  It outputs a
snippet of shell script to be passed to C<eval> in the calling shell.
END_POD
    );

    $class->register_option(
        name        => 'wrap-ssh',
        alias       => 's',
        dispatch_to => 'wrap_ssh',
        summary     => 'pass all args after -- to ssh',
        description => <<'END_POD'
A wrapper around invoking ssh to connect to a specified host.  Ensures the
environment is set up to pass the authentication key and other data to the
C<bcvi> client on the remote server.
END_POD
    );

    $class->register_option(
        name        => 'version',
        alias       => 'v',
        dispatch_to => 'show_versions',
        summary     => 'display bcvi version number',
        description => <<'END_POD'
When invoking a command use this option to indicate that the arguments are not
filenames and the translation of relative pathnames to absolute should be
skipped.
END_POD
    );

    $class->register_option(
        name        => 'no-path-xlate',
        alias       => 'n',
        summary     => 'skip translation of args from relative to absolute',
        description => <<'END_POD'
Displays the version number of the bcvi client and if applicable, of the
listener process.
END_POD
    );

    $class->register_option(
        name        => 'port',
        alias       => 'p',
        arg_spec    => '=i',
        arg_name    => '<port>',
        summary     => 'listener port number',
        description => <<'END_POD'
Port number to listen on (default is user_id * 10 + 9).
END_POD
    );

    $class->register_option(
        name        => 'command',
        alias       => 'c',
        arg_spec    => '=s',
        arg_name    => '<cmnd>',
        summary     => 'command to send over back-channel',
        description => <<'END_POD'
Use C<cmnd> as the command to send over the back-channel (default: vi).
Recognised commands are described in L<COMMANDS> below.
END_POD
    );

    $class->register_aliases(
        'test -n "$(which bcvi)" && eval "$(bcvi --unpack-term)"',
        'test -n "${BCVI_CONF}"  && alias vi="bcvi"',
        'test -n "${BCVI_CONF}"  && alias bcp="bcvi -c scpd"',
        'test -n "${BCVI_CONF}"  && alias bnotify="bcvi -n -c notify"',
    );

    $class->pod_class->init();

}


sub register_option {
    my $class = shift;
    my $opt   = { @_ };
    my $key   = $opt->{name};
    my($package, $filename, $line) = caller();
    $opt->{provider} = "$package at $filename line $line";
    if(!defined $key or !length $key) {
        die "Can't register option without 'name'";
    }
    warn "option '$key' already registered by $options{$key}->{provider}\n"
        if $options{$key} && !$opt->{force_override};
    $options{$key} = $opt;
}


sub each_option {
    my($class, $sub) = @_;

    $sub->($options{$_}) foreach sort keys %options;
}


sub register_aliases {
    my $class = shift;
    push @aliases, @_;
}


sub shell_aliases {
    my($self) = @_;

    return
        "## START-BCVI\n"
        . join("\n", map { "  $_" } @aliases)
        . "\n## END-BCVI\n";
}


sub load_plugins {
    return;
}


sub hook_client_class {
    # determine calling package
    # adjust inheritance chain
    # set $BCVI::class_map{client};
}


sub hook_server_class {
    # determine calling package
    # adjust inheritance chain
    # set $BCVI::class_map{server};
}


sub process_command_line {
    my $class = shift;

    my $opt = $class->option_defaults();
    my @cfg = $class->getopt_config();

    GetOptions($opt, @cfg) or $class->die_synopsis();

    my $handler = $opt->{listener}
                ? $class->server_class
                : $class->client_class;

    $handler->new(_options => $opt)->dispatch(@main::ARGV);
}


sub option_defaults {
    return { };
}


sub getopt_config {
    my($class) = @_;

    my @spec;
    $class->each_option(sub {
        my($o) = @_;
        my $def = $o->{name};
        $def .= "|$o->{alias}" if defined $o->{alias};
        $def .= $o->{arg_spec} if defined $o->{arg_spec};
        push @spec, $def;
    });
    return @spec
}


sub die_synopsis {
    my($class, $message) = @_;

    warn "$message\n" if $message;
    $class->pod_class->synopsis();
    exit(1);
}


sub new {
    my $class = shift;

    return bless { @_ }, $class;
}


sub dispatch {
    my($self) = @_;

    if(my $method = $self->dispatch_option) {
        $self->$method();
        exit;
    }

    $self->send_command();
}


sub opt {
    my($self, $key) = @_;

    return $self->{_options}->{$key};
}


sub dispatch_option {
    my($self) = @_;

    my @set;
    $self->each_option(sub {
        my($o) = @_;
        push @set, $o
            if my $method = $o->{dispatch_to} && $self->opt($o->{name});
    });
    return unless @set;
    if(@set > 1) {
        @set = map { "--$_->{name}" } @set;
        my $last = pop @set;
        $self->die_synopsis(
            "Which did you want: " . join(', ', @set) . " or $last?"
        );
    }
    return $set[0]->{dispatch_to};
}


sub default_port {
    return $< * 10 + 9;
}


sub default_command {
    return 'vi';
}


sub read_file {
    my($self, $path) = @_;

    return unless -e $path;
    return if -d $path;
    my $data = do {
        open my $fh, '<', $path or die "open($path): $!\n";
        local($/) = undef;
        <$fh>;
    };
    return $data;
}


sub home_directory {
    return (getpwuid($>))[7];
}


sub auth_key_filename {
    my($self) = @_;
    return $self->home_directory() . '/.bcvi_listener_key';
}


##############################################################################
# The BCVI::Client class implements the command-line UI and the client side
# of the BCVI protocol.  You can use inheritance to customise the behaviour
# of this class.
##############################################################################

package BCVI::Client;

BEGIN { @BCVI::Client::ISA = qw( BCVI ); }


sub show_versions {
    my($self) = @_;

    print "bcvi client: $BCVI::VERSION\n";
}


sub show_help {
    my($self) = @_;

    $self->pod_class->full_pod();
}


sub wrap_ssh {
    my($self) = @_;

    my %need_arg = map { $_ => 1} split //, 'bcDeFiLlmOopRS';

    my @orig = @ARGV;
    my(@args, @hosts);
    while(@ARGV) {
        $_ = shift @ARGV;
        if(/^-(.)(.*)$/) {
            push @args, $_;
            push @args, shift @ARGV if $need_arg{$1} && !length($2) && @ARGV;
        }
        else {
            push @args,  $_;
            push @hosts, $_;
        }
    }
    if(@hosts == 1) {
        my($target) = @hosts;
        $target =~ s{^.*\@}{};
        my $remote_port = $self->opt('port') || $self->default_port();
        my $local_port  = $self->listener_port();
        $ENV{TERM} = "$ENV{TERM}\n"
                     . "BCVI_CONF=${target}:localhost:$remote_port:"
                     . $self->get_listener_auth_key();
        unshift @args, "-R $local_port:localhost:$remote_port";
    }
    else {
        warn "bcvi: unable to extract hostname from ssh command line\n";
        @args = @orig;
    }
    system 'ssh', @args;
}


sub listener_port {
    my($self) = @_;

    return $self->default_port();
}


sub get_listener_auth_key {
    my($self) = @_;

    my $auth_file = $self->auth_key_filename();
    my $auth_key = $self->read_file($auth_file)
        or die "Auth key file does not exist: $auth_file";
    chomp($auth_key);
    return $auth_key;
}


sub unpack_term {
    my($self) = @_;

    my @parts = split /\x0D?\x0A/, $ENV{TERM} || '';
    return unless @parts > 1;
    print "TERM=$parts[0]\n";
    shift @parts;
    foreach (@parts) {
        print if s{^(\w+)=(.*)$}{export $1="$2"\n};
    }
}


sub install_to_hosts {
    my($self) = @_;

    die "You must list one or more target hostnames\n" unless @ARGV;

    $self->install_to_host($_) foreach @ARGV;
}


sub install_to_host {
    my($self, $host) = @_;

    $self->install_bin_directory($host);
    $self->install_bcvi_script($host);
    $self->install_remote_aliases($host);
}


sub install_bin_directory {
    my($self, $host) = @_;

    if(system("ssh $host test -d ./bin") != 0) {
        print "Creating bin directory on $host\n";
        system("ssh $host mkdir ./bin") == 0
            or die "** mkdir failed on $host";
    }
}


sub install_bcvi_script {
    my($self, $host) = @_;

    print "Copying bcvi to remote bin directory on $host\n";
    my $output = `scp $0 $host:bin/bcvi 2>&1`;
    if($? != 0) {
        die "** failed to copy bcvi to remote bin directory on $host\n"
            . $output;
    }
}


sub install_remote_aliases {
    my($self, $host) = @_;

    system("ssh $host bin/bcvi --add-aliases") == 0
        or die "** failed to install aliases on $host";
}


sub add_aliases {
    my($self) = @_;

    my $bcvi_commands = $self->shell_aliases();

    $self->update_existing_aliases($bcvi_commands)
    or $self->aliases_initial_install($bcvi_commands);
}


sub update_existing_aliases {
    my($self, $bcvi_commands) = @_;

    foreach my $file ( $self->candidate_rc_files() ) {
        my($script) = $self->read_file($file) or next;
        if(index($script, $bcvi_commands) > -1) {
            print "Found bcvi commands in $file\n";
            return 1;
        }
        if($script =~ s{^## START-BCVI.*^## END-BCVI\r?\n}{$bcvi_commands}sm) {
            open my $fh, '>', $file or die "open($file): $!";
            print $fh $script;
            close($fh);
            print "Updated bcvi commands in $file\n";
            return 1;
        }
        if($script =~ m{^[^#]*\bbcvi\b}m) {
            print "Adhoc bcvi commands found in $file\n"
                  . "*** Manual update may be required.            ***\n"
                  . "*** Consider deleting commands and re-adding. ***\n";
            return 1;
        }
    }
    return;   # No existing aliases found
}


sub aliases_initial_install {
    my($self, $bcvi_commands) = @_;

    my $target = $self->preferred_rc_file();

    open my $fh, '>>', $target or die "open(>>$target): $!";
    print $fh "\n$bcvi_commands\n";
    close($fh);
    print "Added bcvi commands to $target\n";
}


sub candidate_rc_files {
    my($self) = @_;
    my $home = $self->home_directory();
    return(
        "$home/.bashrc_local",
        "$home/.bashrc",
        "$home/.bash_profile_local",
        "$home/.bash_profile",
        "$home/.profile",
        "$home/.common-configs/bashrc",
    );
}


sub preferred_rc_file {
    my($self) = @_;

    # Add to .bashrc_local if it is referenced from .bashrc

    my $home = $self->home_directory();
    my $bashrc       = "$home/.bashrc";
    my $bashrc_local = "$home/.bashrc_local";

    my $script = $self->read_file($bashrc) || '';

    return $script =~ m{/[.]bashrc_local\b}
           ? $bashrc_local
           : $bashrc;
}


##############################################################################
# The BCVI::Server class implements the server ('listener') side of the BCVI
# protocol.  You can use inheritance to customise the behaviour of this class.
##############################################################################

package BCVI::Server;

BEGIN { @BCVI::Server::ISA = qw( BCVI ); }


sub start_listener {
    my($self) = @_;

    die "Listener is not yet implemented\n";
}


##############################################################################
# The BCVI::POD class implements POD extraction and formatting on platforms
# where POD::Text is available.
##############################################################################

package BCVI::POD;

use Pod::Text;
use File::Spec;

my $pod_skeleton;


sub init {
    my($class) = @_;

    $pod_skeleton = do {
        local($/) = undef;
        <DATA>;
    };
    close(DATA);
}


sub full_pod {
    my($class) = @_;

    my $pager = $class->pager();
    my $pod   = $pod_skeleton;
    $pod =~ s{^=for BCVI_OPTIONS_SUMMARY\s*\n}{ $class->option_summary()}me;
    $pod =~ s{^=for BCVI_OPTIONS\s*\n}{ $class->option_detail()}me;
    my $parser = Pod::Text->new (sentence => 1, width => 78);
    $parser->output_fh($pager);
    $parser->parse_string_document($pod);
}


sub synopsis {
    my($class) = @_;

    my $pod = $pod_skeleton;
    $pod =~ s{\A.*?^=head1 SYNOPSIS\s*?\n}{Usage:}ms;
    $pod =~ s{^=.*\z}{}ms;
    $pod .= $class->option_summary();

    print $pod;
}


sub option_summary {
    my($class) = @_;

    my $w   = 12;
    my @lines;
    BCVI->base_class->each_option(sub {
        my($o)    = @_;
        my $short = "--$o->{name}";
        $short    .= "|-$o->{alias}"   if $o->{alias};
        $short    .= " $o->{arg_name}" if $o->{arg_name};
        push @lines, [ $short, $o->{summary} ];
        $w = length($short) if length($short) > $w;
    });

    return join('', map { sprintf("  %-*s  %s\n", $w, @$_) } @lines) . "\n";
}


sub option_detail {
    my($class) = @_;

    my $w   = 12;
    my @lines = "=over 4\n";
    BCVI->base_class->each_option(sub {
        my($o)    = @_;
        my $pod = "\n=item B<--$o->{name}>";
        $pod .= " (alias: -$o->{alias})" if $o->{alias};
        $pod .= " $o->{arg_name}"        if $o->{arg_name};
        $pod .= "\n\n$o->{description}\n";
        push @lines, $pod;
    });
    push @lines, "\n=back\n\n";

    return join "\n\n", @lines;
}


sub pager {
    my @commands = $ENV{PAGER} ? ( $ENV{PAGER} ) : qw(pager less more);
    foreach my $file (@commands) {
        foreach my $dir ( File::Spec->path() ) {
            my $exe_path = File::Spec->catfile($dir, $file);
            if(-x $exe_path) {
                open my $fh, '|-', $exe_path or next;
                return $fh;
            }
        }
    }
    return \*STDOUT;
}


__DATA__

=head1 NAME

bcvi - Back-channel vi, proxy commands back over ssh

=head1 SYNOPSIS

  bcvi [options] [<files>]

  Options:

=for BCVI_OPTIONS_SUMMARY

=head1 DESCRIPTION

This utility works with SSH to allow commands run on the SSH server to be
'proxied' back to the SSH client machine.  For example:

=over 4

=item *

user F<sue> establishes an SSH connection from her workstation to a server
named F<pluto> and runs the command C<bcvi .bashrc>

=item *

bcvi tunnels the details back to sue's workstation which then invokes the
command C<gvim scp://pluto//home/sue/.bashrc>

=item *

the result is that sue gets a responsive GUI editor running on her local
machine, but editing a file on the remote machine

=back

=head1 OPTIONS

=for BCVI_OPTIONS

=head1 USING BCVI

You'll need to start a listener process on your workstation (perhaps from
your window manager session startup).

  bcvi -l &

To install the bcvi client to a remote machine:

  bcvi --install <hostname>

To ssh to a server with tunnelling enabled:

  bcvi --wrap-ssh -- hostname

To enable bcvi on all ssh connections:

  alias ssh="bcvi --wrap-ssh --"

On a target server, you'll need to unpack the overloaded TERM variable:

  test -n "$(which bcvi)" && eval "$(bcvi --unpack-term)"

To use vi over the back-channel:

  bcvi filename

The installation to a remote server should set up aliases, e.g.:

  test -n "${BCVI_CONF}"  && alias vi="bcvi"
  test -n "${BCVI_CONF}"  && alias bcp="bcvi -c scpd"

=head1 COPYRIGHT

Copyright 2007-2010 Grant McLean E<lt>grantm@cpan.orgE<gt>

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut


