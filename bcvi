#!/usr/bin/perl
##############################################################################
#
# Script:   bcvi
#
# Author:   Grant McLean <grant@catalyst.net.nz>
#
# Description:
#
# The 'Back-Channel vim' tool works with SSH to allow commands which are run
# on an SSH server to invoke processes back on the originating SSH client
# machine.
#

use strict;
use warnings;

use Pod::Usage;
use Getopt::Long qw(GetOptions);
use File::Spec;
use Sys::Hostname;

my $VERSION = '2.01';

my %opt = (
    port    => ($< * 10 + 9),
    command => 'vi',
);

if(!GetOptions(\%opt,
    'add-aliases',
    'command|c=s',
    'help|?',
    'install',
    'listener|l',
    'no-path-xlate|n',
    'port|p=s',
    'unpack-term',
    'version|v',
    'wrap-ssh|s',
)) {
    pod2usage(-exitval => 1,  -verbose => 0);
}


pod2usage(-exitstatus => 0, -verbose => 2) if($opt{'help'});

if($opt{listener}) {
    my $listener = BCVI::Listener->new(%opt);
    $listener->loop();
}
elsif($opt{'unpack-term'}) { unpack_term();      }
elsif($opt{'wrap-ssh'})    { wrap_ssh();         }
elsif($opt{'install'})     { install_to_host();  }
elsif($opt{'add-aliases'}) { add_aliases();      }
elsif($opt{'version'})     { show_versions();    }
else                       { run_command(@ARGV); }

exit 0;


sub run_command {
    my @files = map {
        $opt{'no-path-xlate'} ? $_ : File::Spec->rel2abs($_)
    } @_;

    my $command = $opt{command};
    my($alias, $gateway, $port, $auth_key) = connection_details();
    my $sock = IO::Socket::INET->new(PeerAddr => "$gateway:$port")
        or die "Can't connect to '$gateway:$port': $!\n";
    binmode($sock);
    my $welcome = <$sock>;
    if(!$welcome or $welcome !~ /^200 READY/) {
        die "No listener?\n";
    }
    if($opt{version}) {
        my($version) = $welcome =~ m{^200 READY \(([\d.]+)\)};
        $version ||= 'unknown';
        print "bcvi server: $version\n";
        exit;
    }
    $sock->write("AUTH $auth_key\x0a");
    $sock->write(join qq{\x0A}, $alias, $command, @files, qq{\x0A})
        or die "Error sending command through backchannel: $!";
}


sub connection_details {
    my $env = $ENV{BCVI_CONF} || '';
    my($alias, $gateway, $port, $auth_key) = split(/:/, $env);
    $alias   ||= hostname();
    $gateway ||= 'localhost';
    $port    ||= $opt{port};
    return($alias, $gateway, $port, $auth_key);
}


sub unpack_term {
    my @parts = split /\x0D?\x0A/, $ENV{TERM} || '';
    return unless @parts > 1;
    print "TERM=$parts[0]\n";
    shift @parts;
    foreach (@parts) {
        print if s{^(\w+)=(.*)$}{export $1="$2"\n};
    }
}


sub show_versions {
    print "bcvi client: $VERSION\n";
    run_command() if $ENV{BCVI_CONF};
}


##############################################################################
# Invokes SSH to connect to a target host, after first arranging for connection
# data to be stuffed into the TERM environment variable.  This data includes 
# the hostname used for the remote end of the connection and well as the
# port that is forwarded back to the listener on the client.

sub wrap_ssh {
    my(@args, @hosts, %need_arg);
    $need_arg{$_} = 1 foreach qw(b c D e F i L l m O o p R S);

    my @orig = @ARGV;
    while(@ARGV) {
        $_ = shift @ARGV;
        if(/^-(.)(.*)$/) {
            push @args, $_;
            push @args, shift @ARGV if $need_arg{$1} && !length($2) && @ARGV;
        }
        else {
            push @args,  $_;
            push @hosts, $_;
        }
    }
    if(@hosts == 1) {
        my($target) = @hosts;
        $target =~ s{^.*\@}{};
        $ENV{TERM} = "$ENV{TERM}\n"
                     . "BCVI_CONF=${target}:localhost:$opt{port}:"
                     . _get_listener_auth_key();
        unshift @args, "-R $opt{port}:localhost:$opt{port}";
    }
    else {
        warn "bcvi: unable to extract hostname from ssh command line\n";
        @args = @orig;
    }
    system 'ssh', @args;
}


sub install_to_host {
    my $host = shift @ARGV or pod2usage(-exitval => 1,  -verbose => 0,
        -message => 'Host name required'
    );

    if(system("ssh $host test -d ./bin") != 0) {
        print "Creating bin directory on host '$host'\n";
        system("ssh $host mkdir ./bin") == 0
            or die "** mkdir failed";
    }
    print "Copying bcvi to remote bin directory\n";
    system("scp $0 $host:bin/") == 0
        or die "** failed to copy bcvi to remote bin directory";
    print "Adding bcvi command aliases\n";
    system("ssh $host bin/bcvi --add-aliases") == 0
        or die "** failed to copy bcvi to remote bin directory";
}


sub add_aliases {
    my $home = (getpwuid($>))[7];

    my $bcvi_commands = desired_commands();

    foreach my $file (
        "$home/.bogusrc",
        "$home/.common-configs/bashrc",
        "$home/.bashrc",
    ) {
        my($script) = read_file($file) or next;
        if(index($script, $bcvi_commands) > -1) {
            print "bcvi commands are in $file\n";
            exit 0;
        }
        if($script =~ s{^## START-BCVI.*^## END-BCVI\r?\n}{$bcvi_commands}sm) {
            open my $fh, '>', $file or die "open($file): $!";
            print $fh $script;
            close($fh);
            print "updated bcvi commands in $file\n";
            exit 0;
        }
        if($script =~ m{^[^#]*\bbcvi\b}m) {
            print "adhoc bcvi commands found in $file\n";
            exit 0;
        }
    }

    # Add to .bashrc_local if it is referenced from .bashrc

    my $bashrc       = "$home/.bashrc";
    my $bashrc_local = "$home/.bashrc_local";

    my $script = read_file($bashrc) || '';
    if($script =~ m{/[.]bashrc_local\b}) {
        open my $fh, '>>', $bashrc_local or die "open(>>$bashrc_local): $!";
        print $fh "\n$bcvi_commands\n";
        close($fh);
        print "added bcvi commands to $bashrc_local\n";
        exit 0;
    }
    else {
        open my $fh, '>>', $bashrc or die "open(>>$bashrc): $!";
        print $fh "\n$bcvi_commands\n";
        close($fh);
        print "added bcvi commands to $bashrc\n";
        exit 0;
    }

    die "bcvi commands do not appear to be installed\n";
}


sub desired_commands {

    return <<'EOF'
## START-BCVI
  test -n "$(which bcvi)" && eval "$(bcvi --unpack-term)"
  test -n "${BCVI_CONF}"  && alias vi="bcvi"
  test -n "${BCVI_CONF}"  && alias bcp="bcvi -c scpd"
  test -n "${BCVI_CONF}"  && alias bnotify="bcvi -n -c notify"
## END-BCVI
EOF
}


sub read_file {
    my($path) = @_;
    return unless -e $path;
    return if -d $path;
    my $data = do {
        open my $fh, '<', $path or die "open($path): $!\n";
        local($/) = undef;
        <$fh>;
    };
    return $data;
}


sub _get_listener_auth_key {
    my $auth_file = BCVI::Listener::auth_key_filename();
    open my $fh, '<', $auth_file or die "open($auth_file): $!";
    my $auth_key = <$fh>;
    chomp($auth_key);
    return $auth_key;
}



package BCVI::Listener;

use IO::Socket::INET;
use IO::Select;
use Scalar::Util qw(refaddr);
use File::Spec;
use POSIX        qw(:errno_h);
use Digest::MD5  qw(md5_hex);

sub new {
    my($class, %opt) = @_;

    eval { require Desktop::Notify; };
    if($@) {
        warn "bcvi warning: Desktop::Notify not installed\n";
        $@ = '';
    }

    _save_pid();
    my $listener = IO::Socket::INET->new(
        LocalAddr => "localhost:$opt{port}",
        ReuseAddr => 1,
        Proto     => 'tcp',
        Listen    => 5,
    ) or die "Error creating listener for port 'localhost:$opt{port}': $!";

    return bless {
        _listener => $listener,
        _selector => IO::Select->new($listener),
        _options  => \%opt,
        _auth_key => _gen_auth_key(),
    }, $class;
}

sub _save_pid {
    my $pid_file = File::Spec->catfile(_home_dir(), '.bcvi.pid');
    if(-e $pid_file) {
        my $old_pid = do {
          local($/); open my $fh, $pid_file or die "open($pid_file): $!";
          <$fh>;
        };
        _kill_pid($old_pid) if $old_pid;
    }
    open my $fh, '>', $pid_file or die "open(>$pid_file): $!";
    print $fh "$$\n";
}


sub _kill_pid {
    my($pid) = @_;

    chomp($pid);
    foreach my $i (1..5) {
        if(kill 0, $pid) {
            kill($i > 2 ? 9 : 1, $pid);
        }
        elsif($! == ESRCH) {   # no such process
            return;
        }
        elsif($! == EPERM) {   # process belongs to another user
            return;
        }
        sleep 1;
    }
}


sub _gen_auth_key {
    my $data = 'BCVI:' . $$ . time . {} . rand();
    my $auth_key = md5_hex($data);

    my $auth_file = auth_key_filename();
    open my $fh, '>', $auth_file or die "open(>$auth_file): $!";
    print $fh $auth_key, "\n";
    close($fh);

    return $auth_key;
}


sub auth_key_filename {
    return _home_dir() . '/.bcvi_listener_key';
}


sub _home_dir {
    return $ENV{HOME} || (getpwuid($<))[7];
}


sub loop {
    my $self = shift;

    while(my @ready = $self->{_selector}->can_read) {
        foreach my $fh (@ready) {
            if($fh == $self->{_listener}) {
                $self->accept_connection();
            }
            else {
                $self->handle_data($fh);
            }
        }
    }
}


sub accept_connection {
    my $self = shift;

    my $sock = $self->{_listener}->accept;
    binmode($sock);
    my $key = refaddr($sock);
    $self->{_selector}->add($sock);
    $self->{$key} = { fh  => $sock, buf => '', };
    $sock->write(qq{200 READY ($VERSION)\x0A});
}


sub handle_data {
    my($self, $sock) = @_;

    my $key = refaddr($sock);

    my $buf;
    my $bytes = sysread $sock, $buf, 4096;
    if($bytes) {
        $self->{$key}->{buf} .= $buf;
        if($self->{$key}->{buf} =~ m{^(.*?)\x0A\x0A\z}s) {
            $self->run_command($1);
            $self->{$key}->{buf} = '';
        }
    }
    else {
        $self->{_selector}->remove($sock);
        $sock->close;
        delete $self->{$key};
    }
}


sub run_command {
    my($self, $string) = @_;

    my($auth, $alias, $command, @files) = split /\x0A/, $string;
    if($auth ne "AUTH $self->{_auth_key}") {
        warn "bcvi: invalid auth from host '$alias', command '$command'\n";
        return;
    }
    my $method = "execute_${command}";
    if(!$self->can($method)) {
        warn "bcvi: unsupported command '$command' - ignored\n";
        return;
    }
    $self->$method($alias, @files);
}


sub execute_vi {
    my($self, $alias, @files) = @_;

    s{^}{scp://$alias/} foreach @files;

    system('gvim', '--', @files);
}


sub execute_scpd {
    my($self, $alias, @files) = @_;

    my $home = _home_dir();

    s{^}{$alias:} foreach @files;

    system('scp', '--', @files, "$home/Desktop");
}


sub execute_notify {
    my($self, $alias, @parts) = @_;

    my $title = "Notification from $alias";

    my $message = join ' ', @parts;

    if(not Desktop::Notify->can('new')) {
        warn "bcvi warning: can't pop up notifications without Desktop::Notify\n";
        warn qq{$title:\n  "$message"\n};
        return;
    }

    my $notify = Desktop::Notify->new();

    my $notification = $notify->create(
        summary => $title,
        body    => $message,
        timeout => 10000,
    );

    $notification->show();
}

__END__

=head1 NAME

bcvi - Back-channel vi, proxy commands back over ssh

=head1 SYNOPSIS

  bcvi [options] [<files>]

  Options:

   -l|--listener        start in listener mode
   -p|--port <port>     listener port number
   -c|--command <cmnd>  command to send over back-channel
   -n|--no-path-xlate   skip translation of args from relative to absolute
   -s|--wrap-ssh        pass all args after -- to ssh
      --unpack-term     unpack the overloaded TERM variable
      --install <host>  copy bcvi to <host>
      --add-aliases     install bcvi into bash startup files
   -?|--help            detailed help message

=head1 DESCRIPTION

This utility works with SSH to allow commands run on the SSH server to be
'proxied' back to the SSH client machine.  For example:

=over 4

=item *

user F<sue> establishes an SSH connection from her workstation to a server
named F<pluto> and runs the command C<bcvi .bashrc>

=item *

bcvi tunnels the details back to sue's workstation which then invokes the
command C<gvim scp://pluto//home/sue/.bashrc>

=item *

the result is that sue gets a responsive GUI editor running on her local
machine, but editing a file on the remote machine

=back


=head1 OPTIONS

=over 4

=item B<--listener> (alias: -l)

Start a (background) listener process.

=item B<< --port <port> >> (alias: -p)

Port number to listen on (default is user_id * 10 + 9).

=item B<< --command <cmnd> >> (alias: -c)

Use C<cmnd> as the command to send over the back-channel (default: vi).
Recognised commands are:

=over 4

=item vi

Invokes C<gvim> on the remote file - after translating the host+path to
an scp URI.

=item scpd

Uses C<scp> to copy the file to the calling user's F<~/Desktop>.

=item notify

Uses the desktop notification protocol to display a message on the calling
user's desktop.

=back

=item B<< --no-path-xlate >> (alias -n)

When invoking a command use this option to indicate that the arguments are not
filenames and the translation of relative pathnames to absolute should be
skipped.

=item B<< --install <host> >>

Copy the C<bcvi> script to the C<$HOME/bin> directory on the specified host
and then remotely invoke it with the C<--add-aliases> option.

=item B<< --add-aliases >>

Edit the bash startup script to add (or update) the required command aliases
for bcvi.

=item B<< --unpack-term >>

This option is intended for use from a F<.profile> script.  It outputs a
snippet to shell script to be passed to C<eval> in the calling shell.

The C<bcvi> script overloads the TERM environment variable (which is
propagated by ssh) to 'smuggle' config data to the remote shell.

=item B<-?>

Display this documentation.

=back

=head1 USING BCVI

You'll need to start a listener process on your workstation (perhaps from
your window manager session startup?

  bcvi -l &

To ssh to a server with tunnelling enabled:

  bcvi --wrap-ssh -- hostname

To enable bcvi on all ssh connections:

  alias ssh="bcvi --wrap-ssh --"

On a target server, you'll need to unpack the overloaded TERM variable:

  test -n "$(which bcvi)" && eval "$(bcvi --unpack-term)"

To use vi over the back-channel:

  bcvi filename

You might want to set up command aliases:

  test -n "${BCVI_CONF}"  && alias vi="bcvi"
  test -n "${BCVI_CONF}"  && alias bcp="bcvi -c scpd"

=head1 COPYRIGHT 

Copyright 2007-2010 Grant McLean E<lt>grantm@cpan.orgE<gt>

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself. 



=cut



